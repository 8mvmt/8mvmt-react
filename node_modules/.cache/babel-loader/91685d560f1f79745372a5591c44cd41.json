{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StarknetBlockProvider = void 0;\n\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\n\nconst react_1 = require(\"react\");\n\nconst starknet_1 = require(\"../starknet\");\n\nconst context_1 = require(\"./context\");\n\nfunction StarknetBlockProvider(_ref) {\n  let {\n    interval,\n    children\n  } = _ref;\n  const {\n    library\n  } = (0, starknet_1.useStarknet)();\n  const [block, setBlock] = (0, react_1.useState)(undefined);\n  const [loading, setLoading] = (0, react_1.useState)(undefined);\n  const [error, setError] = (0, react_1.useState)(undefined);\n  const fetchBlock = (0, react_1.useCallback)(() => {\n    if (library) {\n      library.getBlock().then(newBlock => {\n        setBlock(oldBlock => {\n          // The new block is a different object from the old one\n          // so simply updating the value of block would cause the state\n          // to change and trigger a re-render.\n          // This is especially bad because the block is used to trigger\n          // state updates downstream.\n          // Compare the new and old block hashes and update only if\n          // they changed. Notice we use hashes and not block numbers\n          // because we want to update the block in case of rollbacks.\n          if (oldBlock?.block_hash === newBlock.block_hash) {\n            return oldBlock;\n          } // Reset error and return new block.\n\n\n          setError(undefined);\n          return newBlock;\n        });\n      }).catch(() => {\n        setError('failed fetching block');\n      }).finally(() => setLoading(false));\n    }\n  }, [library, setLoading, setError, setBlock]);\n  (0, react_1.useEffect)(() => {\n    // Set to loading on first load\n    setLoading(true); // Fetch block immediately\n\n    fetchBlock();\n    const intervalId = setInterval(() => {\n      fetchBlock();\n    }, interval ?? 5000);\n    return () => clearInterval(intervalId);\n  }, [fetchBlock, interval]);\n  return (0, jsx_runtime_1.jsx)(context_1.StarknetBlockContext.Provider, {\n    value: {\n      data: block,\n      loading,\n      error\n    },\n    children: children\n  });\n}\n\nexports.StarknetBlockProvider = StarknetBlockProvider;","map":{"version":3,"mappings":";;;;;;;;;AAAA;;AAGA;;AAEA;;AAOA,SAAgBA,qBAAhB,OAG6B;EAAA,IAHS;IACpCC,QADoC;IAEpCC;EAFoC,CAGT;EAC3B,MAAM;IAAEC;EAAF,IAAc,6BAApB;EAEA,MAAM,CAACC,KAAD,EAAQC,QAAR,IAAoB,sBAAuCC,SAAvC,CAA1B;EACA,MAAM,CAACC,OAAD,EAAUC,UAAV,IAAwB,sBAA8BF,SAA9B,CAA9B;EACA,MAAM,CAACG,KAAD,EAAQC,QAAR,IAAoB,sBAA6BJ,SAA7B,CAA1B;EAEA,MAAMK,UAAU,GAAG,yBAAY,MAAK;IAClC,IAAIR,OAAJ,EAAa;MACXA,OAAO,CACJS,QADH,GAEGC,IAFH,CAESC,QAAD,IAAa;QACjBT,QAAQ,CAAEU,QAAD,IAAa;UACpB;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA,IAAIA,QAAQ,EAAEC,UAAV,KAAyBF,QAAQ,CAACE,UAAtC,EAAkD;YAChD,OAAOD,QAAP;UACD,CAXmB,CAapB;;;UACAL,QAAQ,CAACJ,SAAD,CAAR;UACA,OAAOQ,QAAP;QACD,CAhBO,CAAR;MAiBD,CApBH,EAqBGG,KArBH,CAqBS,MAAK;QACVP,QAAQ,CAAC,uBAAD,CAAR;MACD,CAvBH,EAwBGQ,OAxBH,CAwBW,MAAMV,UAAU,CAAC,KAAD,CAxB3B;IAyBD;EACF,CA5BkB,EA4BhB,CAACL,OAAD,EAAUK,UAAV,EAAsBE,QAAtB,EAAgCL,QAAhC,CA5BgB,CAAnB;EA8BA,uBAAU,MAAK;IACb;IACAG,UAAU,CAAC,IAAD,CAAV,CAFa,CAIb;;IACAG,UAAU;IAEV,MAAMQ,UAAU,GAAGC,WAAW,CAAC,MAAK;MAClCT,UAAU;IACX,CAF6B,EAE3BV,QAAQ,IAAI,IAFe,CAA9B;IAIA,OAAO,MAAMoB,aAAa,CAACF,UAAD,CAA1B;EACD,CAZD,EAYG,CAACR,UAAD,EAAaV,QAAb,CAZH;EAcA,OACE,uBAACqB,+BAAqBC,QAAtB,EAA8B;IAACC,KAAK,EAAE;MAAEC,IAAI,EAAErB,KAAR;MAAeG,OAAf;MAAwBE;IAAxB,CAAR;IAAuCP,UAClEA;EAD2B,CAA9B,CADF;AAKD;;AA3DDwB","names":["StarknetBlockProvider","interval","children","library","block","setBlock","undefined","loading","setLoading","error","setError","fetchBlock","getBlock","then","newBlock","oldBlock","block_hash","catch","finally","intervalId","setInterval","clearInterval","context_1","Provider","value","data","exports"],"sources":["../../../src/providers/block/provider.tsx"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}